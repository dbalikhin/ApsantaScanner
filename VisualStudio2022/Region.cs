// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Microsoft.CodeAnalysis.Sarif
{
    // or from here https://github.com/microsoft/sarif-sdk/blob/main/src/Sarif/Autogenerated/Region.cs
    public class Region
    {
        public bool IsBinaryRegion => this.ByteOffset >= 0;

        public bool IsLineColumnBasedTextRegion => this.StartLine >= 1;

        public bool IsOffsetBasedTextRegion => this.CharOffset >= 0;

        public void PopulateDefaults()
        {
            if (this.IsLineColumnBasedTextRegion)
            {
                this.PopulateLineColumnBasedTextDefaults();
            }

            if (this.IsOffsetBasedTextRegion)
            {
                this.PopulateOffsetBasedTextDefaults();
            }

            if (this.IsBinaryRegion)
            {
                this.PopulateBinaryDefaults();
            }
        }

        private void PopulateLineColumnBasedTextDefaults()
        {
            if (this.EndLine == 0)
            {
                this.EndLine = this.StartLine;
            }

            if (this.StartColumn == 0)
            {
                this.StartColumn = 1;
            }

            if (this.EndColumn == 0)
            {
                this.EndColumn = int.MaxValue;
            }
        }

        private void PopulateOffsetBasedTextDefaults()
        {
            if (this.CharLength == -1)
            {
                this.CharLength = 0;
            }
        }

        private void PopulateBinaryDefaults()
        {
            if (this.ByteLength == -1)
            {
                this.ByteLength = 0;
            }
        }

        public bool IsProperSupersetOf(Region subRegion)
        {
            this.PopulateDefaults();
            subRegion.PopulateDefaults();

            if (this.IsLineColumnBasedTextRegion &&
                subRegion.IsLineColumnBasedTextRegion &&
                !IsLineColumnBasedTextRegionProperSupersetOf(subRegion))
            {
                return false;
            }

            if (this.IsOffsetBasedTextRegion &&
                subRegion.IsOffsetBasedTextRegion &&
                !IsOffsetBasedTextRegionProperSupetSetOf(subRegion))
            {
                return false;
            }

            if (this.IsBinaryRegion &&
                subRegion.IsBinaryRegion &&
                !IsBinaryRegionProperSupersetOf(subRegion))
            {
                return false;
            }

            // if we reach here, the region and context region have been expressed as different property sets,
            // and it is not possible to judge validity without looking at the actual content.
            // It is a potential false negative.
            return true;
        }

        private bool IsLineColumnBasedTextRegionProperSupersetOf(Region subRegion)
        {
            if (this.StartLine > subRegion.StartLine || this.EndLine < subRegion.EndLine)
            {
                return false;
            }

            if (this.StartLine == subRegion.StartLine && this.StartColumn > subRegion.StartColumn)
            {
                return false;
            }

            if (this.EndLine == subRegion.EndLine && this.EndColumn < subRegion.EndColumn)
            {
                return false;
            }

            if (this.StartLine == subRegion.StartLine &&
                this.EndLine == subRegion.EndLine &&
                this.StartColumn == subRegion.StartColumn &&
                this.EndColumn == subRegion.EndColumn)
            {
                return false;
            }

            return true;
        }

        private bool IsBinaryRegionProperSupersetOf(Region subRegion)
        {
            if (this.ByteOffset > subRegion.ByteOffset)
            {
                return false;
            }

            if (GetByteEndOffset(this) < GetByteEndOffset(subRegion))
            {
                return false;
            }

            if (this.ByteOffset == subRegion.ByteOffset && this.ByteLength <= subRegion.ByteLength)
            {
                return false;
            }

            return true;
        }

        private bool IsOffsetBasedTextRegionProperSupetSetOf(Region subRegion)
        {
            if (this.CharOffset > subRegion.CharOffset)
            {
                return false;
            }

            if (GetCharEndOffset(this) < GetCharEndOffset(subRegion))
            {
                return false;
            }

            if (this.CharOffset == subRegion.CharOffset && this.CharLength <= subRegion.CharLength)
            {
                return false;
            }

            return true;
        }

        private static int GetCharEndOffset(Region region)
        {
            return region.CharOffset + region.CharLength;
        }

        private static int GetByteEndOffset(Region region)
        {
            return region.ByteOffset + region.ByteLength;
        }

        /// <summary>
        /// The line number of the first character in the region.
        /// </summary>
        [DataMember(Name = "startLine", IsRequired = false, EmitDefaultValue = false)]
        public virtual int StartLine { get; set; }

        /// <summary>
        /// The column number of the first character in the region.
        /// </summary>
        [DataMember(Name = "startColumn", IsRequired = false, EmitDefaultValue = false)]
        public virtual int StartColumn { get; set; }

        /// <summary>
        /// The line number of the last character in the region.
        /// </summary>
        [DataMember(Name = "endLine", IsRequired = false, EmitDefaultValue = false)]
        public virtual int EndLine { get; set; }

        /// <summary>
        /// The column number of the character following the end of the region.
        /// </summary>
        [DataMember(Name = "endColumn", IsRequired = false, EmitDefaultValue = false)]
        public virtual int EndColumn { get; set; }

        /// <summary>
        /// The zero-based offset from the beginning of the artifact of the first character in the region.
        /// </summary>
        [DataMember(Name = "charOffset", IsRequired = false, EmitDefaultValue = false)]
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
        public virtual int CharOffset { get; set; }

        /// <summary>
        /// The length of the region in characters.
        /// </summary>
        [DataMember(Name = "charLength", IsRequired = false, EmitDefaultValue = false)]
        public virtual int CharLength { get; set; }

        /// <summary>
        /// The zero-based offset from the beginning of the artifact of the first byte in the region.
        /// </summary>
        [DataMember(Name = "byteOffset", IsRequired = false, EmitDefaultValue = false)]
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
        public virtual int ByteOffset { get; set; }

        /// <summary>
        /// The length of the region in bytes.
        /// </summary>
        [DataMember(Name = "byteLength", IsRequired = false, EmitDefaultValue = false)]
        public virtual int ByteLength { get; set; }


        /// <summary>
        /// Specifies the source language, if any, of the portion of the artifact specified by the region object.
        /// </summary>
        [DataMember(Name = "sourceLanguage", IsRequired = false, EmitDefaultValue = false)]
        public virtual string SourceLanguage { get; set; }


        /// <summary>
        /// Initializes a new instance of the <see cref="Region" /> class.
        /// </summary>
        public Region()
        {
            CharOffset = -1;
            ByteOffset = -1;
        }


    }
}